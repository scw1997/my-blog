# 前端工程化

## Webpack

### module/chunk/bundle

![webpack_1.png](/webpack_1.png)
| 定义     | 介绍        | 关系                                                                                                                                                                                             |
|--------|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| module | 它可以是JavaScript文件、CSS文件、图片等，Webpack通过loader将它们转换为有效的module，以供应用程序使用。<br/>在Webpack中，每个Module都会被转换成一个或多个Chunk，并可能包含有对其他Module的依赖。                                    |module是Webpack打包过程的起点和基本单位|
| chunk  | chunk是Webpack在构建过程中生成的中间产物，它代表着一组被合并在一起的modules。这些modules通常基于某种逻辑（如依赖关系、按需加载等）被组织在一起。<br/>默认不进行任何其他配置情况下，Webpack会将所有入口点（entry point）及其依赖的模块打包到一个主要的初始chunk中。可使用代码分割拆分成多个chunk |多个module可以组成一个Chunk，而一个chunk也可以包含多个module。 |
| bundle | bundle是Webpack最终输出的文件，它包含了所有的chunk和module。,如打包后的JavaScript文件、CSS文件、图片等。<br/>这些文件是静态资源，可以直接被浏览器加载和解析。                                                                      |一般来说一个 chunk 对应一个 bundle,但也有例外。比如通过MiniCssExtractPlugin 从chunk中抽离出了bundle.css文件|


### loader & plugin

| 定义     | 功能                                                            | 执行方式                                                                           |
|--------|---------------------------------------------------------------|--------------------------------------------------------------------------------|
| loader | 本质上是一个函数，主要完成文件转换的工作。用于将文件（如.vue、.scss等）编译成Webpack能够理解和处理的模块。 | 主要在模块加载阶段执行，处理模块源代码的转换。<br/>Loader以链式调用的方式工作，从后往前执行，每个Loader的输出作为下一个Loader的输入。 |
| plugin | Plugin主要负责执行更广泛的任务，如打包优化、资源管理和环境变量注入等，它们不直接操作文件内容。            | 在整个Webpack生命周期内，通过监听特定的事件来执行逻辑。                                                |

###  hash/chunkHash/contentHash

| 定义     | 使用范围       | 特点                              | 适用场景                             |
|--------|-------------------------------------|---------------------------------|----------------------------------|
| hash | 整个构建过程 | 任何一个文件改变，所有文件的hash值都会改变         | 不推荐在生产环境中使用,会导致缓存失效的粒度过大，影响网站性能。| 
| chunkHash | 每个独立的入口chunk文件及其依赖          | 入口文件或其依赖改变时，对应的文件名改变 |          生产环境中管理代码分割后的文件缓存                        |    
|contentHahs|       文件内容级别                          | 文件内容改变时，文件名改变                                 |管理CSS、图片等文件的缓存|

### 核心工作原理

Webpack 最核心的功能，是将各种类型的资源，包括图片、css、js等，转译、组合、拼接、生成 JS 格式的 bundle 文件。

#### 初始化阶段
- 初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数
- 创建编译器对象：用上一步得到的参数创建 Compiler 对象
- 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等
- 开始编译：执行 compiler 对象的 run 方法
- 确定入口：根据配置中的 entry 找出所有的入口文件，调用 compilition.addEntry 将入口文件转换为用于记录模块间依赖关系的 dependence 对象
#### 构建阶段
- 编译模块(make)：根据 entry 对应的 dependence 创建 module 对象，调用 loader 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理
- 完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图
##### 生成阶段
- 输出资源(seal)：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- 写入文件系统(emitAssets)：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

### 性能优化

常见的优化方法总结：

#### 提升编译速率

- 使用thread-loader开启多进程打包。
- 使用babel缓存等方法缓存编译结果。
- 使用DllPlugin预编译依赖模块。将不经常变动的第三方库单独打包，避免在每次构建时都重新编译这些模块。
- 开发环境下减少监听文件，提升HMR速度

#### 减小打包体积

- 压缩js,css，图片等资源
- Tree Shaking
- 使用CDN链接代替本地安装第三方依赖
- 代码分割
### 零碎

- `babel-loader`只是将ts转成js，不包括类型检查功能；`ts-loader`默认转译+类型检查都支持。
- `babel`只负责转换新特性，而`babel-polyfill`负责转换新的api


## 其他

- 搭建专属npm镜像服务器：[https://cloud.tencent.com/developer/article/1722254](https://cloud.tencent.com/developer/article/1722254)

