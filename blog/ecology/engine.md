# 前端工程化

## Webpack

### module/chunk/bundle

![webpack_1.png](/webpack_1.png)
| 定义     | 介绍        | 关系                                                                                                                                                                                             |
|--------|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| module | 它可以是JavaScript文件、CSS文件、图片等，Webpack通过loader将它们转换为有效的module，以供应用程序使用。<br/>在Webpack中，每个Module都会被转换成一个或多个Chunk，并可能包含有对其他Module的依赖。                                    |module是Webpack打包过程的起点和基本单位|
| chunk  | chunk是Webpack在构建过程中生成的中间产物，它代表着一组被合并在一起的modules。这些modules通常基于某种逻辑（如依赖关系、按需加载等）被组织在一起。<br/>默认不进行任何其他配置情况下，Webpack会将所有入口点（entry point）及其依赖的模块打包到一个主要的初始chunk中。可使用代码分割拆分成多个chunk |多个module可以组成一个Chunk，而一个chunk也可以包含多个module。 |
| bundle | bundle是Webpack最终输出的文件，它包含了所有的chunk和module。,如打包后的JavaScript文件、CSS文件、图片等。<br/>这些文件是静态资源，可以直接被浏览器加载和解析。                                                                      |一般来说一个 chunk 对应一个 bundle,但也有例外。比如通过MiniCssExtractPlugin 从chunk中抽离出了bundle.css文件|


### loader & plugin

| 定义     | 功能                                                            | 执行方式                                                                           |
|--------|---------------------------------------------------------------|--------------------------------------------------------------------------------|
| loader | 本质上是一个函数，主要完成文件转换的工作。用于将文件（如.vue、.scss等）编译成Webpack能够理解和处理的模块。 | 主要在模块加载阶段执行，处理模块源代码的转换。<br/>Loader以链式调用的方式工作，从后往前执行，每个Loader的输出作为下一个Loader的输入。 |
| plugin | Plugin主要负责执行更广泛的任务，如打包优化、资源管理和环境变量注入等，它们不直接操作文件内容。            | 在整个Webpack生命周期内，通过监听特定的事件来执行逻辑。                                                |

###  hash/chunkHash/contentHash

| 定义     | 使用范围       | 特点                              | 适用场景                             |
|--------|-------------------------------------|---------------------------------|----------------------------------|
| hash | 整个构建过程 | 任何一个文件改变，所有文件的hash值都会改变         | 不推荐在生产环境中使用,会导致缓存失效的粒度过大，影响网站性能。| 
| chunkHash | 每个独立的入口chunk文件及其依赖          | 入口文件或其依赖改变时，对应的文件名改变 |          生产环境中管理代码分割后的文件缓存                        |    
|contentHahs|       文件内容级别                          | 文件内容改变时，文件名改变                                 |管理CSS、图片等文件的缓存|

### 核心工作原理

Webpack 最核心的功能，是将各种类型的资源，包括图片、css、js等，转译、组合、拼接、生成 JS 格式的 bundle 文件。

#### 初始化阶段
- 初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数
- 创建编译器对象：用上一步得到的参数创建 Compiler 对象
- 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等
- 开始编译：执行 compiler 对象的 run 方法
- 确定入口：根据配置中的 entry 找出所有的入口文件，调用 compilition.addEntry 将入口文件转换为用于记录模块间依赖关系的 dependence 对象
#### 构建阶段
- 编译模块(make)：根据 entry 对应的 dependence 创建 module 对象，调用 loader 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理
- 完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图
##### 生成阶段
- 输出资源(seal)：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- 写入文件系统(emitAssets)：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统


### HMR热更新执行原理
- 使用 webpack-dev-server (后面简称 WDS)托管静态资源，在内存中创建虚拟文件系统，同时以 Runtime 方式注入 HMR 客户端代码
- 浏览器加载页面后，与 WDS 建立 WebSocket 连接
- Webpack 监听到文件变化后，增量构建发生变更的模块，并通过 WebSocket 发送 hash 事件
- 浏览器接收到 hash 事件后，请求 manifest 资源文件，确认增量变更范围
- 浏览器加载发生变更的增量模块
- Webpack 运行时触发变更模块的 module.hot.accept 回调，执行代码变更逻辑

### Tree Shaking原理

- Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中
- Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用
- 生成产物时，若变量没有被其它模块使用则使用Terser删除对应的导出语句
:::warning
标记功能需要配置 `optimization.usedExports = true` 开启
:::

### 性能优化

常见的优化方法总结：

#### 提升编译速率

- 使用thread-loader开启多进程打包。
- 使用babel缓存，持久化缓存（filesystem）等方法缓存编译结果。
- 使用DllPlugin预编译依赖模块。将不经常变动的第三方库单独打包，避免在每次构建时都重新编译这些模块。
- 开发环境下减少监听文件，提升HMR速度

:::tip 持久化缓存
将首次构建结果持久化到本地文件系统，在下次执行构建时跳过一系列解析、链接、编译等非常消耗性能的操作，直接复用 module、chunk 的构建结果。
:::

#### 减小打包体积

- 压缩js,css，图片等资源
- Tree Shaking
- 使用CDN链接代替本地安装第三方依赖

### 优化运行时体验
- 使用异步加载，例如点击某个按钮的时候才需要加载某个图片资源
- 使用splitChunks实现代码分割（将分割成不同的 bundle，按需加载资源）
```js
module.exports = {  
  // ...  
  optimization: {  
    splitChunks: {  
      chunks: 'all', // 可以是 'all'（推荐用于生产环境）、'async（默认）' 或 'initial'  
      minSize: 20000, //生成 chunk 的最小体积（以字节为单位）  
      maxSize: 0, // 生成chunk的最大体积（以字节为单位），如果设置为 0，则没有限制  
      minChunks: 1, // 被至少多少个 chunk 共享时，才会被分割  
      maxInitialRequests: 30, // 入口点处的并行请求的最大数量  
      automaticNameDelimiter: '~', // 生成名称时使用的分隔符  
      enforceSizeThreshold: 50000, // 强制分割前需要达到的体积阈值  
      cacheGroups: {  
        // 缓存组可以继承和覆盖 splitChunks 里的选项 
        //创建了一个名为 vendors 的缓存组，用于将来自 node_modules 的模块分割到一个单独的 bundle 中。  
        vendors: {  
          test: /[\\/]node_modules[\\/]/,  
          priority: -10, // 优先级  
          reuseExistingChunk: true, // 如果可复用已有 chunk，则不再创建新的 chunk  
        },  
        default: false, // 禁用默认的缓存组  
      },  
    },  
  },  
  // ...  
};
     
```
- 预获取和预加载

预获取（prefetch）：浏览器空闲的时候进行资源的拉取
```js
import(/* webpackPrefetch: true */ './test.png').then();
```
预加载（preload）：提前加载后面会用到的关键资源（慎用）
```js
import(/* webpackPreload: true */ './test.png').then();
```
### 零碎

- `babel-loader`只是将ts转成js，不包括类型检查功能；`ts-loader`默认转译+类型检查都支持。
- `babel`只负责转换新特性，而`babel-polyfill`负责转换新的api


## Vite

| 方面   | Webpack                                                                                               | Vite                                                                                                                                                            |
|------|-------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 开发环境 | 需要通过构建整个项目的依赖图，进行压缩、合并、转换（非js文件需要loader转换）、分割等操作，将所有资源打包成一个或多个 bundle 文件，每次修改都需要打包                    | 先启动开发服务器，利用原生`ES Module`提供源码(jsx,vue等文件)，无需打包（即冷启动），使用`esbuild`(用go编写,多线程速度快)主要针对模块化模式不统一如CommonJs的第三方依赖进行**预构建**，在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行按需编译，然后返回给浏览器。 |
| 热更新  | 需要把改动模块及相关依赖全部编译                                                                                      | HMR时只需让浏览器重新请求该模块，同时利用浏览器的缓存（源码模块协商缓存，依赖模块强缓存）来优化请求                                                                                                             |
| 生产构建 | webpack在生产环境下会将所有代码打包成一个或多个bundle，以便进行优化、压缩和代码拆分等操作，以提高性能和加载速度。但是js只能单线程运行，无法利用多核CPU的优势，项目越大会很影响打包速度。 | 同样基于原生es module，使用`rollup`(esm支持良好,打包体积小,生态完善稳定)进行生产环境打包。                                                                                                       |
| 使用成本 | webpack 概念和配置项比较复杂繁多                                                                                  | 大多常用功能（如css 预处理，分包，压缩，HMR等）已内置                                                                                                                                  |
| 兼容性  | 兼容性较好，能普遍兼容现有浏览器                                                                                      | 适合现代支持ES Module特性的浏览器                                                                                                                                           |                                                     |
:::info vite生产环境为何不使用esbuild打包？
Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容。一些针对构建 应用 的重要功能仍然还在持续开发中,特别是代码分割和 CSS 处理方面。
:::

## 其他

- 搭建专属npm镜像服务器：[https://cloud.tencent.com/developer/article/1722254](https://cloud.tencent.com/developer/article/1722254)
- package.json文件中的`peerDependencies`作用：当前项目与项目中需要安装的某个包都需要依赖于另一个包A，则可在此指定包A的版本且可共享该包
