# 前端工程化

## Webpack

### module/chunk/bundle

![webpack_1.png](/webpack_1.png)
| 定义     | 介绍        | 关系                                                                                                                                                                                             |
|--------|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| module | 它可以是JavaScript文件、CSS文件、图片等，Webpack通过loader将它们转换为有效的module，以供应用程序使用。<br/>在Webpack中，每个Module都会被转换成一个或多个Chunk，并可能包含有对其他Module的依赖。                                    |module是Webpack打包过程的起点和基本单位|
| chunk  | chunk是Webpack在构建过程中生成的中间产物，它代表着一组被合并在一起的modules。这些modules通常基于某种逻辑（如依赖关系、按需加载等）被组织在一起。<br/>默认不进行任何其他配置情况下，Webpack会将所有入口点（entry point）及其依赖的模块打包到一个主要的初始chunk中。可使用代码分割拆分成多个chunk |多个module可以组成一个Chunk，而一个chunk也可以包含多个module。 |
| bundle | bundle是Webpack最终输出的文件，它包含了所有的chunk和module。,如打包后的JavaScript文件、CSS文件、图片等。<br/>这些文件是静态资源，可以直接被浏览器加载和解析。                                                                      |一般来说一个 chunk 对应一个 bundle,但也有例外。比如通过MiniCssExtractPlugin 从chunk中抽离出了bundle.css文件|


### loader & plugin

| 定义     | 功能                                                            | 执行方式                                                                           |
|--------|---------------------------------------------------------------|--------------------------------------------------------------------------------|
| loader | 本质上是一个函数，主要完成文件转换的工作。用于将文件（如.vue、.scss等）编译成Webpack能够理解和处理的模块。 | 主要在模块加载阶段执行，处理模块源代码的转换。<br/>Loader以链式调用的方式工作，从后往前执行，每个Loader的输出作为下一个Loader的输入。 |
| plugin | Plugin主要负责执行更广泛的任务，如打包优化、资源管理和环境变量注入等，它们不直接操作文件内容。            | 在整个Webpack生命周期内，通过监听特定的事件来执行逻辑。                                                |

###  hash/chunkHash/contentHash

| 定义     | 使用范围       | 特点                              | 适用场景                             |
|--------|-------------------------------------|---------------------------------|----------------------------------|
| hash | 整个构建过程 | 任何一个文件改变，所有文件的hash值都会改变         | 不推荐在生产环境中使用,会导致缓存失效的粒度过大，影响网站性能。| 
| chunkHash | 每个独立的入口chunk文件及其依赖          | 入口文件或其依赖改变时，对应的文件名改变 |          生产环境中管理代码分割后的文件缓存                        |    
|contentHahs|       文件内容级别                          | 文件内容改变时，文件名改变                                 |管理CSS、图片等文件的缓存|

### 性能优化

常见的优化方法总结：

#### 提升编译速率

- 使用thread-loader开启多进程打包。
- 使用babel缓存等方法缓存编译结果。
- 使用DllPlugin预编译依赖模块。将不经常变动的第三方库单独打包，避免在每次构建时都重新编译这些模块。
- 开发环境下减少监听文件，提升HMR速度

#### 减小打包体积

- 压缩js,css，图片等资源
- Tree Shaking
- 使用CDN链接代替本地安装第三方依赖
- 代码分割
### 零碎

- `babel-loader`只是将ts转成js，不包括类型检查功能；`ts-loader`默认转译+类型检查都支持。
- `babel`只负责转换新特性，而`babel-polyfill`负责转换新的api


## 其他

- 搭建专属npm镜像服务器：[https://cloud.tencent.com/developer/article/1722254](https://cloud.tencent.com/developer/article/1722254)

