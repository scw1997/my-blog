

# 浏览器渲染机制

浏览器地址栏输入url后发生了什么?...

## 网络通信

### URL解析

浏览器先会判断输入的地址是不是一个合法的URL结构，如果不是，浏览器会使用搜索引擎对这个字符串进行搜索，是的话则进行DNS解析。

### DNS解析


- **缓存判断**

    判断是正确的URL格式之后，DNS会在我们的缓存(包括[浏览器缓存],操作系统缓存等)中查询是否有当前域名的IP地址。
    
    如果命中缓存则直接会直接从缓存中拿取对应的IP地址，如果是强缓存，则直接返回缓存资源，跳过以下所有步骤。

    没有命中则执行IP查询。
   
- **IP查询**
   
   依靠DNS协议（基于`udp`）通过`迭代查询`和`递归查询`结合使用的方式将域名解析为IP地址。
   ![IP查询](/dns.png)
  
   :::tip 为什么dns解析是基于udp而非tcp协议?

    dns解析过程是一个服务器的查找过程。因为域名分为一级/二级...域名，所以每一级域名都会迭代去查询。如果它采用tcp协议的话，每经过一次域名查询，域名服务器都会经过三次握手,四次挥手。但是udp就不会，他会直接发包然后确认。
 
    相较于udp，tcp是更加安全，可靠的,但是这也造成了它相对于udp消耗更多时间。

    :::

### 网络请求

- **建立连接**

  **（1）TCP三次握手**
  
  ![三次握手](/shake-hands.png)

  其中：
  - SYN：表示请求建立连接
  - Seq：随机序列号
  - ACK：上一次握手的Seq+1
  
  1：由浏览器B发起，告诉服务器S：我要给你发送请求（`seq=x`）

  2：由服务器S发起，告诉客户端B：收到了B的请求（`seq=y,ack=seq+1`），我已经准备接受了，你可以发送了

  3：由浏览器B发送，告诉服务器S：收到了S的回复（`seq=z,ack=seq+1`），那我马上发送给你

  :::tip 为什么不能是2次握手

  假如只有2次握手：
  - 客户端发送第一个SYN包时如果发送阻塞，超时后会重新发送SYN包（二者标识一致）。服务端接收了重传的SYN包然后回传了第二次握手并建立了连接。后续如果阻塞的SYN包（此时理应已被视作无效连接）消除阻塞到达了服务端，会让客户端和服务器再次建立连接但却是无意义的。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了第二次握手，但是客户端不会再次发出确认。由于服务器收不到确认，所以没有建立连接。`防止了已失效的连接请求报文段，避免资源浪费`
  - tcp是全双工通信。第二次握手结束后，浏览器知道服务端收到了消息并回复了自己，但是服务端并不知道自己回复的消息对方是否收到，`无法保证接下来的通信是否可靠`。
  :::

  :::tip 为什么不应该是4次握手
  
  第1，2次之后，客户端确保了自己的发送和接收无问题。

  第3次之后，服务端确保了自己的发送（第2次握手回复的消息被收到了）和接收无问题。

  所以无需第4次。

  :::

  **（2） TLS四次握手（`仅https`）**

  HTTPS 建立连接的过程，先进行 TCP 三次握手，再进行 TLS 四次握手：

  1：客户端发出请求，向服务端提供客户端支持的`协议版本`（如TLS 1.0），`加密方法`（如RSA公钥加密），`随机数`(`client random`，用于生成对话密钥)等信息。

  2：服务器回复请求，向客户端确认协议版本，加密方法。并发送服务器证书、非对称加密的公钥，以及另一个随机数(`server random`)。

  3：客户端收到服务器证书并验证，有问题会向访问用户警告是否继续通信。如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串新的随机数（`premaster secret`）并通过服务端下发的公钥及加密方法进行加密，然后发送给服务端。并由此前三个随机数通过一定的算法来生成 `“会话密钥”`（Session Key）。

  4：服务器收到客户端发送的数据（premaster secret），此时服务端也拿到了三个随机数，使用同样的算法计算出 “会话密钥”（Session Key）。

  至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用 “会话密钥” 加密内容。

- **发起请求**
  
  建立连接后，开始正式发起HTTP/HTTPS请求，此过程详见：[HTTP协议]


## 页面渲染

请求完成后，正常情况浏览器会收到服务端返回的html，css，js以及图片等静态资源。

![渲染过程](/html-render.png)

### HTML解析

解析HTML，会构建`DomTree`:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
  </head>
  <body>
    <p>p标签的内容</p>
    <div>div标签的内容</div>
   </body>
</html>
```
![html解析](/html-parse.png)

解析HTML过程中，当遇到`script`标签时：

- 默认情况下会阻塞HTML的解析（比如script可能有修改dom的操作），并且会等待script脚本下载并执行完毕，然后继续解析HTML。
- 如果script标签含有`defer`或者`async`属性，则不会阻塞HTML解析。

::: tip
`defer`：会并行下载js脚本，下载过程不阻塞html解析，且等待其解析完成才执行该脚本。所以可放心访问和操作dom。

`async`：会并行下载js脚本，下载过程不阻塞html解析，但下载完成后会立即执行该脚本，故执行顺序不可控。涉及dom操作可能会报错。
:::

### CSS解析

解析HTML过程中，当遇到CSS Link标签时，会由浏览器负责下载对应的CSS文件，此时并不会阻塞HTML的解析，下载完成后进行CSS解析，并构建`CSSOM`(CSS Object Model，CSS对象模型），也称`Style Rules`。

![css解析](/style-rules.png)

### 构建Render Tree

有了DOM Tree 和 CSSOM Tree 后，就可以两个结合来构建`Render Tree`：



[浏览器缓存]:/principle/browser-cache
[HTTP协议]:/principle/http
